<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Routing Algorithms for TSP: Graph Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Routing Algorithms for TSP
   </div>
   <div id="projectbrief">FEUP - DA Project 2</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="class_graph-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Graph Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Class representing a graph.  
 <a href="class_graph.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_graph_8h_source.html">Graph.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a05c45e4efdf867792139ddf3628c0b60" id="r_a05c45e4efdf867792139ddf3628c0b60"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_vertex.html">Vertex</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a05c45e4efdf867792139ddf3628c0b60">findVertex</a> (int id) const</td></tr>
<tr class="memdesc:a05c45e4efdf867792139ddf3628c0b60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds a vertex in the graph based on its id.  <br /></td></tr>
<tr class="separator:a05c45e4efdf867792139ddf3628c0b60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d2f69946b29fee07c53cb6552c7690e" id="r_a2d2f69946b29fee07c53cb6552c7690e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a2d2f69946b29fee07c53cb6552c7690e">addVertex</a> (int id)</td></tr>
<tr class="memdesc:a2d2f69946b29fee07c53cb6552c7690e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a vertex to the graph.  <br /></td></tr>
<tr class="separator:a2d2f69946b29fee07c53cb6552c7690e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a480675e98227b5cea4d990d301d43eee" id="r_a480675e98227b5cea4d990d301d43eee"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a480675e98227b5cea4d990d301d43eee">addVertex</a> (int id, double longitude, double latitude)</td></tr>
<tr class="memdesc:a480675e98227b5cea4d990d301d43eee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a vertex to the graph.  <br /></td></tr>
<tr class="separator:a480675e98227b5cea4d990d301d43eee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec796be6bcc74ce93b43df4c93525776" id="r_aec796be6bcc74ce93b43df4c93525776"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#aec796be6bcc74ce93b43df4c93525776">addEdge</a> (int source, int dest, double w) const</td></tr>
<tr class="memdesc:aec796be6bcc74ce93b43df4c93525776"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an edge between two vertices in the graph.  <br /></td></tr>
<tr class="separator:aec796be6bcc74ce93b43df4c93525776"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf29d1d4926915e6b4bac336b74a4293" id="r_abf29d1d4926915e6b4bac336b74a4293"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#abf29d1d4926915e6b4bac336b74a4293">addBidirectionalEdge</a> (int source, int dest, double w) const</td></tr>
<tr class="memdesc:abf29d1d4926915e6b4bac336b74a4293"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a bidirectional edge between two vertices in the graph.  <br /></td></tr>
<tr class="separator:abf29d1d4926915e6b4bac336b74a4293"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e805d1e47b847b9665cf978aa31ab4a" id="r_a1e805d1e47b847b9665cf978aa31ab4a"><td class="memItemLeft" align="right" valign="top">unordered_map&lt; int, <a class="el" href="class_vertex.html">Vertex</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a1e805d1e47b847b9665cf978aa31ab4a">getVertexSet</a> () const</td></tr>
<tr class="memdesc:a1e805d1e47b847b9665cf978aa31ab4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the set of vertices in the graph.  <br /></td></tr>
<tr class="separator:a1e805d1e47b847b9665cf978aa31ab4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8863cfdad2955bd23306b3e56b0aa51" id="r_ad8863cfdad2955bd23306b3e56b0aa51"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#ad8863cfdad2955bd23306b3e56b0aa51">getEdgeWeight</a> (<a class="el" href="class_vertex.html">Vertex</a> *source, <a class="el" href="class_vertex.html">Vertex</a> *dest)</td></tr>
<tr class="memdesc:ad8863cfdad2955bd23306b3e56b0aa51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the weight of the edge between two vertices in the graph.  <br /></td></tr>
<tr class="separator:ad8863cfdad2955bd23306b3e56b0aa51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af36c0a3ce405505de739224ffe2557c0" id="r_af36c0a3ce405505de739224ffe2557c0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#af36c0a3ce405505de739224ffe2557c0">TSPBacktracking</a> (<a class="el" href="class_vertex.html">Vertex</a> *currentVertex, int destId, int count, double cost, double &amp;res)</td></tr>
<tr class="memdesc:af36c0a3ce405505de739224ffe2557c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the Traveling Salesman Problem (TSP) using backtracking algorithm.  <br /></td></tr>
<tr class="separator:af36c0a3ce405505de739224ffe2557c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a049913a4f0aa5b5371de6809ab585bc8" id="r_a049913a4f0aa5b5371de6809ab585bc8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a049913a4f0aa5b5371de6809ab585bc8">TSPTriangular</a> (double &amp;res)</td></tr>
<tr class="memdesc:a049913a4f0aa5b5371de6809ab585bc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves the Traveling Salesman Problem (TSP) using the Triangular TSP heuristic.  <br /></td></tr>
<tr class="separator:a049913a4f0aa5b5371de6809ab585bc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb18a1f9d2ad51214d4211d60edf6860" id="r_acb18a1f9d2ad51214d4211d60edf6860"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#acb18a1f9d2ad51214d4211d60edf6860">prim</a> ()</td></tr>
<tr class="memdesc:acb18a1f9d2ad51214d4211d60edf6860"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a minimum spanning tree (MST) using Prim's algorithm.  <br /></td></tr>
<tr class="separator:acb18a1f9d2ad51214d4211d60edf6860"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4b61821079f925dcbf4c29d61a98a1c" id="r_ac4b61821079f925dcbf4c29d61a98a1c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#ac4b61821079f925dcbf4c29d61a98a1c">preorderTraversal</a> (<a class="el" href="class_vertex.html">Vertex</a> *v, std::vector&lt; <a class="el" href="class_vertex.html">Vertex</a> * &gt; &amp;preorder, int n)</td></tr>
<tr class="memdesc:ac4b61821079f925dcbf4c29d61a98a1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a preorder traversal starting from a given vertex.  <br /></td></tr>
<tr class="separator:ac4b61821079f925dcbf4c29d61a98a1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81a736d93710e0c0a610833bece321c2" id="r_a81a736d93710e0c0a610833bece321c2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a81a736d93710e0c0a610833bece321c2">TSPNearestNeighbor</a> (double &amp;res)</td></tr>
<tr class="memdesc:a81a736d93710e0c0a610833bece321c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves the Traveling Salesman Problem (TSP) using the Nearest Neighbor heuristic.  <br /></td></tr>
<tr class="separator:a81a736d93710e0c0a610833bece321c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0dcc15c2ebb0e1e4e356da8f1366369" id="r_af0dcc15c2ebb0e1e4e356da8f1366369"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#af0dcc15c2ebb0e1e4e356da8f1366369">TSPRealWorldNearestNeighbor</a> (double &amp;res, int startingVertexId)</td></tr>
<tr class="memdesc:af0dcc15c2ebb0e1e4e356da8f1366369"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves the Traveling Salesman Problem (TSP) using the Real-World Nearest Neighbor heuristic.  <br /></td></tr>
<tr class="separator:af0dcc15c2ebb0e1e4e356da8f1366369"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-attribs" name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:ab7e67844f410b03007947dd0a47d6583" id="r_ab7e67844f410b03007947dd0a47d6583"><td class="memItemLeft" align="right" valign="top"><a id="ab7e67844f410b03007947dd0a47d6583" name="ab7e67844f410b03007947dd0a47d6583"></a>
unordered_map&lt; int, <a class="el" href="class_vertex.html">Vertex</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>vertices</b></td></tr>
<tr class="separator:ab7e67844f410b03007947dd0a47d6583"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Class representing a graph. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="abf29d1d4926915e6b4bac336b74a4293" name="abf29d1d4926915e6b4bac336b74a4293"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf29d1d4926915e6b4bac336b74a4293">&#9670;&#160;</a></span>addBidirectionalEdge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Graph::addBidirectionalEdge </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>w</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a bidirectional edge between two vertices in the graph. </p>
<p>This function adds a bidirectional edge between the vertices with the given source and destination ids. If either of the vertices does not exist in the graph, the function returns false, indicating that the edge could not be added. Otherwise, it creates two edges: one from source to dest and another from dest to source, each with the specified weight. Additionally, it sets the reverse pointers for the edges to maintain bidirectionality.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The id of the source vertex. </td></tr>
    <tr><td class="paramname">dest</td><td>The id of the destination vertex. </td></tr>
    <tr><td class="paramname">w</td><td>The weight of the edge.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the bidirectional edge is successfully added, false otherwise.</dd></dl>
<p>@complexity The time complexity of this function depends on the time complexity of finding vertices in the graph, adding edges to the vertices, and setting reverse pointers, all of which are O(1) in the worst case. </p>

</div>
</div>
<a id="aec796be6bcc74ce93b43df4c93525776" name="aec796be6bcc74ce93b43df4c93525776"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec796be6bcc74ce93b43df4c93525776">&#9670;&#160;</a></span>addEdge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Graph::addEdge </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>w</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds an edge between two vertices in the graph. </p>
<p>This function adds an edge from the vertex with the source id to the vertex with the destination id. If either of the vertices does not exist in the graph, the function returns false, indicating that the edge could not be added. Otherwise, it adds the edge to the origin vertex and checks if there is a corresponding reverse edge in the destination vertex. If a reverse edge exists and has the same weight as the newly added edge, it sets the reverse pointers for both edges to maintain bidirectionality.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The id of the source vertex. </td></tr>
    <tr><td class="paramname">dest</td><td>The id of the destination vertex. </td></tr>
    <tr><td class="paramname">w</td><td>The weight of the edge.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the edge is successfully added, false otherwise.</dd></dl>
<p>@complexity The time complexity of this function depends on the time complexity of finding vertices in the graph, adding edges to the vertices, and setting reverse pointers, all of which are O(1) in the worst case. </p>

</div>
</div>
<a id="a2d2f69946b29fee07c53cb6552c7690e" name="a2d2f69946b29fee07c53cb6552c7690e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d2f69946b29fee07c53cb6552c7690e">&#9670;&#160;</a></span>addVertex() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Graph::addVertex </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a vertex to the graph. </p>
<p>This function adds a vertex with the given id and type to the graph. If a vertex with the same id already exists in the graph, the function returns false, indicating that the vertex could not be added. Otherwise, it creates a new vertex, inserts it into the graph's vertex set, and returns true to indicate a successful addition.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>The id of the vertex to be found.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the vertex is successfully added, false otherwise.</dd></dl>
<p>@complexity The time complexity of this function depends on the time complexity of finding a vertex in the graph, which is O(1) in the worst case, and inserting a new vertex into the vertex set, which is also O(1) in the worst case. </p>

</div>
</div>
<a id="a480675e98227b5cea4d990d301d43eee" name="a480675e98227b5cea4d990d301d43eee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a480675e98227b5cea4d990d301d43eee">&#9670;&#160;</a></span>addVertex() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Graph::addVertex </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>longitude</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>latitude</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a vertex to the graph. </p>
<p>This function adds a vertex with the given id and type to the graph. If a vertex with the same id already exists in the graph, the function returns false, indicating that the vertex could not be added. Otherwise, it creates a new vertex, inserts it into the graph's vertex set, and returns true to indicate a successful addition.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>The id of the vertex to be found. </td></tr>
    <tr><td class="paramname">longitude</td><td>The longitude of the vertex to be found. </td></tr>
    <tr><td class="paramname">latitude</td><td>The latitude of the vertex to be found.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the vertex is successfully added, false otherwise.</dd></dl>
<p>@complexity The time complexity of this function depends on the time complexity of finding a vertex in the graph, which is O(1) in the worst case, and inserting a new vertex into the vertex set, which is also O(1) in the worst case. </p>

</div>
</div>
<a id="a05c45e4efdf867792139ddf3628c0b60" name="a05c45e4efdf867792139ddf3628c0b60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05c45e4efdf867792139ddf3628c0b60">&#9670;&#160;</a></span>findVertex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_vertex.html">Vertex</a> * Graph::findVertex </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds a vertex in the graph based on its id. </p>
<p>This function searches for a vertex with the given id in the graph's vertex set. If the vertex is found, a pointer to it is returned; otherwise, nullptr is returned to indicate that the vertex could not be found.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>The id of the vertex to be found.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the vertex if found, nullptr otherwise.</dd></dl>
<p>@complexity The time complexity of this function depends on the time complexity of finding an element in an unordered_map, which is O(1) in the worst case. </p>

</div>
</div>
<a id="ad8863cfdad2955bd23306b3e56b0aa51" name="ad8863cfdad2955bd23306b3e56b0aa51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8863cfdad2955bd23306b3e56b0aa51">&#9670;&#160;</a></span>getEdgeWeight()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Graph::getEdgeWeight </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_vertex.html">Vertex</a> *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vertex.html">Vertex</a> *&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the weight of the edge between two vertices in the graph. </p>
<p>This function retrieves the weight of the edge between the specified source and destination vertices. It first attempts to find the edge connecting the two vertices. If the edge does not exist, it calculates the weight using the Haversine formula based on the latitude and longitude coordinates of the vertices. If either of the vertices has invalid coordinates (latitude or longitude set to numeric_limits&lt;double&gt;::max()), indicating that it's not a valid vertex, the function throws a runtime error. If the edge exists, it returns the weight of the edge.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A pointer to the source vertex. </td></tr>
    <tr><td class="paramname">dest</td><td>A pointer to the destination vertex.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The weight of the edge between the source and destination vertices, or the calculated distance based on their coordinates if the edge does not exist.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>If the edge is not found and either of the vertices has invalid coordinates.</td></tr>
  </table>
  </dd>
</dl>
<p>@complexity The time complexity of this function depends on the time complexity of finding the edge between the vertices, which is O(1) in the average case for most graph representations. If the edge does not exist, the complexity of calculating the distance between the vertices using the Haversine formula is O(1). </p>

</div>
</div>
<a id="a1e805d1e47b847b9665cf978aa31ab4a" name="a1e805d1e47b847b9665cf978aa31ab4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e805d1e47b847b9665cf978aa31ab4a">&#9670;&#160;</a></span>getVertexSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unordered_map&lt; int, <a class="el" href="class_vertex.html">Vertex</a> * &gt; Graph::getVertexSet </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the set of vertices in the graph. </p>
<dl class="section return"><dt>Returns</dt><dd>An unordered map containing the vertices of the graph, where the keys are vertex ids and the values are pointers to the corresponding vertices.</dd></dl>
<p>This function returns a copy of the unordered map containing all vertices in the graph. It does not modify the original graph.</p>
<p>@complexity O(1) </p>

</div>
</div>
<a id="ac4b61821079f925dcbf4c29d61a98a1c" name="ac4b61821079f925dcbf4c29d61a98a1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4b61821079f925dcbf4c29d61a98a1c">&#9670;&#160;</a></span>preorderTraversal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::preorderTraversal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_vertex.html">Vertex</a> *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="class_vertex.html">Vertex</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>preorder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a preorder traversal starting from a given vertex. </p>
<p>This function recursively performs a preorder traversal starting from the specified vertex in the graph. It adds each visited vertex to the preorder vector and continues the traversal by recursively visiting adjacent vertices that are connected to the current vertex via their paths. The traversal continues until all vertices are visited or until the preorder vector contains 'n' vertices, where 'n' is the total number of vertices in the graph.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>A pointer to the starting vertex for the preorder traversal. </td></tr>
    <tr><td class="paramname">preorder</td><td>Reference to the vector to store the vertices in preorder traversal order. </td></tr>
    <tr><td class="paramname">n</td><td>The total number of vertices in the graph.</td></tr>
  </table>
  </dd>
</dl>
<p>@complexity The time complexity of this function depends on the number of vertices in the graph and the structure of the graph. In the worst case, where the graph is a complete graph, the complexity is O(|V| + |E|), where |V| is the number of vertices and |E| is the number of edges in the graph. </p>

</div>
</div>
<a id="acb18a1f9d2ad51214d4211d60edf6860" name="acb18a1f9d2ad51214d4211d60edf6860"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb18a1f9d2ad51214d4211d60edf6860">&#9670;&#160;</a></span>prim()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::prim </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a minimum spanning tree (MST) using Prim's algorithm. </p>
<p>This function implements Prim's algorithm to find the minimum spanning tree (MST) of the graph starting from an arbitrary vertex. It initializes each vertex's distance to infinity and sets its path and visited status accordingly. Then, it selects a starting vertex, sets its distance to 0, and initializes a mutable priority queue to manage vertices based on their distances. The algorithm iterates by extracting the vertex with the minimum distance from the priority queue, marking it as visited, and updating the distances of its adjacent vertices if shorter paths are found. The process continues until all vertices are visited.</p>
<p>@complexity The time complexity of Prim's algorithm depends on the implementation of the priority queue. Using a binary heap-based priority queue, the complexity is O((|V| + |E|) log |V|), where |V| is the number of vertices and |E| is the number of edges in the graph. </p>

</div>
</div>
<a id="af36c0a3ce405505de739224ffe2557c0" name="af36c0a3ce405505de739224ffe2557c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af36c0a3ce405505de739224ffe2557c0">&#9670;&#160;</a></span>TSPBacktracking()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::TSPBacktracking </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_vertex.html">Vertex</a> *&#160;</td>
          <td class="paramname"><em>currentVertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>destId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>cost</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>res</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs the Traveling Salesman Problem (TSP) using backtracking algorithm. </p>
<p>This function recursively explores all possible paths starting from the current vertex to find the shortest Hamiltonian cycle that visits all vertices exactly once and returns to the starting vertex. It backtracks when all vertices have been visited to check if the current path forms a cycle and updates the minimum cost if necessary.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">currentVertex</td><td>A pointer to the current vertex being visited in the TSP traversal. </td></tr>
    <tr><td class="paramname">destId</td><td>The id of the destination vertex (starting vertex) for completing the cycle. </td></tr>
    <tr><td class="paramname">count</td><td>The number of vertices visited in the current path. </td></tr>
    <tr><td class="paramname">cost</td><td>The total cost of the current path. </td></tr>
    <tr><td class="paramname">res</td><td>Reference to the minimum cost found so far, updated recursively.</td></tr>
  </table>
  </dd>
</dl>
<p>@complexity The time complexity of this function depends on the number of permutations of vertices to explore, resulting in O(V!) in the worst case, where 'V' is the number of vertices in the graph. </p>

</div>
</div>
<a id="a81a736d93710e0c0a610833bece321c2" name="a81a736d93710e0c0a610833bece321c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81a736d93710e0c0a610833bece321c2">&#9670;&#160;</a></span>TSPNearestNeighbor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::TSPNearestNeighbor </td>
          <td>(</td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>res</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solves the Traveling Salesman Problem (TSP) using the Nearest Neighbor heuristic. </p>
<p>This function applies the Nearest Neighbor heuristic to find an approximate solution to the TSP. Starting from an arbitrary vertex, it iteratively selects the nearest unvisited neighbor until all vertices are visited, forming a Hamiltonian cycle. It calculates the total cost of the cycle by summing the weights of the edges traversed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">res</td><td>Reference to the variable to store the total cost of the Hamiltonian cycle.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>If no neighboring vertex is found during the traversal.</td></tr>
  </table>
  </dd>
</dl>
<p>@complexity The time complexity of this function primarily depends on the number of vertices in the graph and the implementation of finding the nearest neighbor, resulting in O(|V|^2), where |V| is the number of vertices. </p>

</div>
</div>
<a id="af0dcc15c2ebb0e1e4e356da8f1366369" name="af0dcc15c2ebb0e1e4e356da8f1366369"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0dcc15c2ebb0e1e4e356da8f1366369">&#9670;&#160;</a></span>TSPRealWorldNearestNeighbor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::TSPRealWorldNearestNeighbor </td>
          <td>(</td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>startingVertexId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solves the Traveling Salesman Problem (TSP) using the Real-World Nearest Neighbor heuristic. </p>
<p>This function applies the Real-World Nearest Neighbor heuristic to find an approximate solution to the TSP. Starting from a specified vertex, it iteratively selects the nearest unvisited neighbor based on real-world distances (edge weights) until all vertices are visited, forming a Hamiltonian cycle. It calculates the total cost of the cycle by summing the weights of the edges traversed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">res</td><td>Reference to the variable to store the total cost of the Hamiltonian cycle. </td></tr>
    <tr><td class="paramname">startingVertexId</td><td>The ID of the vertex from which the traversal should start.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>If no neighboring vertex or path is found during the traversal.</td></tr>
  </table>
  </dd>
</dl>
<p>@complexity The time complexity of this function primarily depends on the number of vertices in the graph and the implementation of finding the nearest neighbor, resulting in O(|V| + |E|), where |V| is the number of vertices and |E| is the number of edges in the graph. </p>

</div>
</div>
<a id="a049913a4f0aa5b5371de6809ab585bc8" name="a049913a4f0aa5b5371de6809ab585bc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a049913a4f0aa5b5371de6809ab585bc8">&#9670;&#160;</a></span>TSPTriangular()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::TSPTriangular </td>
          <td>(</td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>res</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solves the Traveling Salesman Problem (TSP) using the Triangular TSP heuristic. </p>
<p>This function applies the Triangular TSP heuristic, which consists of constructing a minimum spanning tree (MST) using Prim's algorithm with a binary heap-based priority queue, and then performing a preorder traversal on the MST to generate a Hamiltonian cycle. It calculates the total cost of the cycle by summing the weights of the edges in the preorder traversal path.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">res</td><td>Reference to the variable to store the total cost of the Hamiltonian cycle.</td></tr>
  </table>
  </dd>
</dl>
<p>@complexity The time complexity of this function primarily depends on the time complexity of constructing the minimum spanning tree using Prim's algorithm, which is O((|V| + |E|) log |V|) with adjacency list representation and a binary heap-based priority queue. The complexity of the preorder traversal is O(|V|), and calculating edge weights is O(1) on average. Overall, the complexity is dominated by Prim's algorithm. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="_graph_8h_source.html">Graph.h</a></li>
<li><b>Graph.cpp</b></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
